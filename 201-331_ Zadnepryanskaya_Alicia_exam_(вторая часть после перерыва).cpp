// 201-331_ Zadnepryanskaya_Alicia_exam_p1.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <string>  //строки
#include <fstream> //заголовочный файл для работы с файлами
#include <vector> //вектор
#include <math.h> //для выполнения математических задач (простых)
using namespace std;


/*
int zad1(vector<bool> f)  //функция ДЛЯ ЗАДАНИЯ 1
{
	return sqrt(f.size()); //при помощи f.size() считаем длину вектора по указанной в задании формуле
}



vector <bool> zad2() { //функция ДЛЯ ЗАДАНИЯ 2
	vector <bool> read_from_file; //создается вектор для чтения файла
	bool bool1; //
	ifstream in;  //поток для чтения 
	in.open("C:\\Users\\Elya\\Desktop\\file_name.txt"); //открытие фай
	while (in >> bool1) {
		read_from_file.push_back(bool1);
	}
	return read_from_file;
}



bool zad3() { //функция ДЛЯ ЗАДАНИЯ 3
	vector <bool> write_to_file = { 1, 0, 1, 0, 1 }; //создается вектор с указанными значениями для записи в файл
	vector <bool> read_from_file; //вектор для чтения файла
	bool bool1;
	ofstream out; //поток для записи
	out.open("C:\\Users\\Elya\\Desktop\\file_name.txt");
	for (int i = 0; i < write_to_file.size(); i++) { // здесь происходит запись зн. вектора write_to_file, используя цикл for
		out << write_to_file[i] << " ";
	}
	out.close();
	ifstream check;
	check.open("C:\\Users\\Elya\\Desktop\\file_name.txt"); // для проверки на открытие 
	if (check.is_open()) 
	{
		while (check >> bool1) {
			read_from_file.push_back(bool1);
		}
		for (int i = 0; i < read_from_file.size(); i++) {
			cout << read_from_file[i] << endl; //выводятся записанные в файл значения
		}
		cout << endl;
		if (read_from_file == write_to_file) {
			cout << "Возвращённое значение: ";
			check.close();
			return true; //возвращается true, если выполнено условие
		}
	}
}

*/

int char_to_int(char symbol) {  //функция ДЛЯ ЗАДАНИЯ 8 (2 часть экзамена)
	if (symbol == 'I') {       //В СТРОКАХ 64-84 происходит перевод символов (из римских чисел)
		return 1;			   //в арабские числа по алгоритму из задания
	}
	if (symbol == 'V') {						
		return 5;											
	}
	if (symbol == 'X') {
		return 10;
	}
	if (symbol == 'L') {
		return 50;
	}
	if (symbol == 'C') {
		return 100;
	}
	if (symbol == 'D') {
		return 500;
	}
	if (symbol == 'M') {
		return 1000;
	}
	return -1; //spanking для отбрасывания числа, если его вдруг не окажется
}

int roman_to_arabic(string& roman_number) { //функция ДЛЯ ЗАДАНИЯ 8 (2 часть экзамена)
	int result = 0; //return result
	for (int i = 0; i < roman_number.size(); i++) { //здесь происходит превращение римского числа в арабское
		int symbol_1 = char_to_int(roman_number[i]); //берется первая цифра (конвертированная)
		if (i + 1 < roman_number.size()) { //проверка на оконечность числа 
			int symbol_2 = char_to_int(roman_number[i + 1]); //следующая цифра преобразуется в арабскую
			if (symbol_1 >= symbol_2) { //складывания результатов в зависимости от величины цифры / числа
				result = result + symbol_1;
			}
			else {
				result = result + symbol_2 - symbol_1;
				i++;
			}
		}
		else {
			result = result + symbol_1; //последнее преобразование
		}
	}
	return result;
}



int func_Pascal(int n) //функция ДЛЯ ЗАДАНИЯ 9 (2 часть экзамена)
{
	int i, x;
	x = 1;
	for (i = 1; i <= n; i++)
	{
		x *= i;
	};
	return x;
}



int func_substr_len(string str) { //функция ДЛЯ ЗАДАНИЯ 10 (2 часть экзамена)

	int n = str.size(); //длина всей строки
	int cur_len = 1; // длина текущей подстроки
	int max_len = 1; // результат
	int prev_index; // предыдущий индекс
	int* visited = new int[sizeof(int) * 256]; //динамический массив для проверки символов
	for (int i = 0; i < 256; i++) { 
		visited[i] = -1;
		visited[str[0]] = 0;
	}
	for (int i = 1; i < n; i++) { //
		prev_index = visited[str[i]];
		if (prev_index == -1 || i - cur_len > prev_index) {
			cur_len++;
		}
		else {
			if (cur_len > max_len) {

				max_len = cur_len;
				cur_len = i - prev_index;
			}
		}
		visited[str[i]] = i;
	}
	if (cur_len > max_len) { //проверка двух последних последовательностей
		max_len = cur_len;
	}
	return max_len;
}



int main() 
{
	setlocale(LC_ALL, "RUS");
	/*
	//ПЕРВОЕ ЗАДАНИЕ: По заданному вектору значений f булевой функции 
	//возвращает количество аргументов n этой функции. Длина вектора f есть pow(2,n).

	vector<bool> f = { 1, 1, 0, 1 }; //здесь задан вектор f (bool)
	cout << "Количество аргументов n: " << zad1(f) << endl; //при помощи функции zad1(f) возв. кол-во аргументов




	//ВТОРОЕ ЗАДАНИЕ: По заданному расположению и имени файла file_name вернуть вектор значений булевой функции

	cout << "Вектор: "; 
	for (int i = 0; i < zad2().size(); i++) { //при помощи цикла возвращается вектор значений булевой функции
		cout << zad2().at(i) << " "; 
	}
	cout << endl;




	//ТРЕТЬЕ ЗАДАНИЕ: Записать заданный вектор значений f булевой функции в файл, 
	//заданный расположением и имененем файла file_name. Вернуть true при успешной записи.

	cout << zad3() << endl; //при помощи функции zad3() выполнено задание




	//ЧЕТВЕРТОЕ ЗАДАНИЕ: По заданному вектору значений f булевой функции вернуть строку, 
	//в которой записана таблица истинности этой булевой функции. 
	//Считать, что имена аргументов это х1,х2,х3,х4 и т.д.

	vector <bool> f;
	int size = 4;
	bool elem;
	cout << "Введите буль: ";
	for (int i = 0; i < size; i++) { //вводим элементы буля
		cin >> elem;
		f.push_back(elem);
	}
	bool x0 = f.at(0), x1 = f.at(1), x2 = f.at(2), x3 = f.at(3);
	unsigned int z = pow(2, size);
	cout << "  Х0 " << " Х1 " << " Х2 " << " Х3 " << "      ИЛИ ";
	cout << "   И " << "  НЕ И " << "  НЕ ИЛИ\n";
	while (z--) { //в данном цикле выводится строка, в которой записана таблица истинности той или иной булевой функции (если совсем кратко)
		cout << "| " << x0 << " | " << x1 << " | " << x2 << " | " << x3 << " | -> | " << (x0 || x1 || x2 || x3);
		cout << " | " << " | " << (x0 && x1 && x2 && x3) << " | ";
		cout << " | " << !(x0 && x1 && x2 && x3) << " | " << " | ";
		cout << !(x0 || x1 || x2 || x3) << " |\n";
		{
			if (z > 8) x0 = 0;
			else x0 = 1;
		}
		{
			if (z > 12 || (z < 9 && z > 4)) x1 = 0;
			else x1 = 1;
		}
		{
			if (z > 14 || (z < 13 && z > 10) || (z < 9 && z > 6) || (z < 5 && z > 2)) x2 = 0;
			else x2 = 1;
		}
		{
			if (z % 2 == 0) x3 = 0;
			else x3 = 1;
		}
	}




	//ПЯТОЕ ЗАДАНИЕ: По заданному вектору значений f булевой функции вернуть строку, 
	//в которой записана СДНФ этой булевой функии. 
	//Считать, что имена аргументов это х1, х2, х3, х4 и т.д.
	//Конъюнкция обозначается&, дизъюнкция V, отрицание ' 

	vector <bool> f;
	int size = 3;
	bool elem;
	cout << "Введите буль: ";
	for (int i = 0; i < size; i++) { //вводим элементы буля
		cin >> elem;
		f.push_back(elem);
	}
	bool x0 = f.at(0), x1 = f.at(1), x2 = f.at(2);
	unsigned int z = pow(2, size); //для разложения функции по всем переменным (формула)
	cout << "  Х0 " << " Х1 " << " Х2 " << "      СКНФ " << endl;
	cout << "| " << x0 << " | " << x1 << " | " << x2 << " |" << " -> | " << (!x0 || x1 || !x2) && (!x0 || x1 || x2) && (x0 || !x1 || x2) && (x0 || x1 || x2); //вывод СДНФ




	//ШЕСТОЕ ЗАДАНИЕ: По заданному вектору значений f булевой функции вернуть строку, 
	//в которой записана СКНФ этой булевой функии. 
	//Считать, что имена аргументов это х1, х2, х3, х4 и т.д.
	//Конъюнкция обозначается&, дизъюнкция V, отрицание '

	vector <bool> f;
	int size = 3;
	bool elem;
	cout << "Введите буль: ";
	for (int i = 0; i < size; i++) { //вводим элементы буля
		cin >> elem;
		f.push_back(elem);
	}
	bool x0 = f.at(0), x1 = f.at(1), x2 = f.at(2);
	unsigned int z = pow(2, size);
	cout << "  Х0 " << " Х1 " << " Х2 " << "      СДНФ " << endl;
	cout << "| " << x0 << " | " << x1 << " | " << x2 << " |" << " -> | " << !x0 && !x1 && !x2 || !x0 && x1 && !x2 || x0 && x1 && !x2 || x0 && x1 && x2; //вывод СКНФ
	



	//СЕДЬМОЕ ЗАДАНИЕ: По заданному вектору значений f булевой функции вернуть строку, 
	//в которой записана СКНФ этой булевой функии. 
	//Считать, что имена аргументов это х1, х2, х3, х4 и т.д.
	//Конъюнкция обозначается&, сумма по модулю 2 обозначается + .
	*/



	//ВОСЬМОЕ ЗАДАНИЕ: Во входной строке записано римское число, 
	//не превышающее трех тысяч. Необходимо вернуть записать его в арабской.

	ifstream RomanInputer;  //поток для чтения
	ofstream RomanOutputer;  //поток для записи
	RomanInputer.open("C:\\Users\\Elya\\Desktop\\roman_input.txt", ios::in); //ios::in нужен для ввода операций в поток
	RomanOutputer.open("C:\\Users\\Elya\\Desktop\\arabic_output.txt", ios::out); //ios::out нужен для вывода операций в поток
	string roman_number;
	RomanInputer >> roman_number; //делаем так, чтобы римское число записалось в файл для ввода
	RomanOutputer << "Арабское число будет выглядеть так: " << roman_to_arabic(roman_number); //арабское число появляется во втором файле (вместе с надписью)

	//ДЕВЯТОЕ ЗАДАНИЕ: треугольник Паскаля
	vector <int> my_func_Pascal;
	int k, j, c; //переменные для цикла
	cout << "\t\t\t\tВведите нижнюю грань: ";
	cin >> k;
	cout << "\t\t\t\tТреугольник Паскаля" << endl;
	cout << "1" << "\n"; //первая строка
	for (j = 1; j <= k; j++) //отвечает за количество строк
	{
		for (c = 0; c <= j; c++) //отвечает за количество символов в самой строке
		{
			cout << (func_Pascal(j) / (func_Pascal(c) * func_Pascal(j - c))) << " "; //берется все из функции
			my_func_Pascal.push_back((func_Pascal(j) / (func_Pascal(c) * func_Pascal(j - c))));
		};
		cout << "\n";
	}
	cout << "\t\t\t\tНижний ряд" << endl;
	for (int i = my_func_Pascal.size() - 1; i >= my_func_Pascal.size() - k - 1; i--) { //здесь выводится последняя строка
		cout << my_func_Pascal.at(i) << " ";
	}

	//ДЕСЯТОЕ ЗАДАНИЕ: По заданной строке input_str вернуть число, 
	//равное размеру самой длинной подстроки, которая не содержит повторяющихся символов.

	string input_str;
	cout << "Введите строку:";
	cin >> input_str; //вводится строка
	cout << "Введённая строка: " << input_str << endl; //здесь эта строка показывается
	int len = func_substr_len(input_str); //считается длина последовательности, которая нужна по условию
	cout << "Длина самой большой и неповторяющейся последовательности: " << len << endl;


	return 0;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
